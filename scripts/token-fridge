#!/usr/bin/env ruby -w

###############
# Setup/Usage #
###############
# This needs the `curl-cmanv2` script from this same `scripts` directory to work. If you don't already have it, see the
# setup/usage instructions at https://raw.githubusercontent.com/scottyschup/dotfiles/main/scripts/curl-cmanv2

# # These are the directory and file the script will live in; feel free to change these to fit your environment:
# token_fridge_root_dir="$HOME/.curlcmanv2"
# mkdir -p $token_fridge_root_dir
# token_fridge_script="$token_fridge_root_dir/token-fridge"
# curl "https://raw.githubusercontent.com/scottyschup/dotfiles/main/scripts/token-fridge" > $token_fridge_script
# chmod +x $token_fridge_script

# # The following adds the campaign generator dir to your path so you can run it with `token_fridge` rather than having to type `~/.curlcmanv2/token_fridge` each time
# # Change the path/name for your `.zshrc` if it's not in your home dir
# echo "export PATH=$token_fridge_root_dir"':$PATH' >> "$HOME/.zshrc"

################
# Dependencies #
################
begin
  verbose = $VERBOSE
  $VERBOSE = nil # Suppress deprecation warnings and the like

  require 'optparse'
rescue LoadError => err
  # Error example:
  #   pry(main)> require 'fake_gem/with/path'
  #   LoadError: cannot load such file -- fake-gem/with/path
  #   from /Users/username/.rbenv/versions/2.4.7/lib/ruby/2.4.0/rubygems/core_ext/kernel_require.rb:55:in `require'
  dependency = err.message.split(' -- ').last
  # Remove '/with/path' from the gem name; noop for all others
  dependency = dependency.split('/').first
  warn "Missing dependency: #{dependency}"
  warn 'Make sure the following command completes successfully before using this script.'
  warn "\tgem install #{dependency}"
  exit 1
ensure
  $VERBOSE = verbose
end

begin
  load "#{__dir__}/curl-cmanv2"
rescue LoadError => err
  $stderr.puts 'This script uses the `curl-cmanv2` script from the same repo, but it could not be found.'
  $stderr.puts 'Make sure both scripts are located in the same directory.'
  exit 1
end

#############
# Ruby code #
#############

class TokenRefrigerator
  DEFAULT_OPTION_OVERRIDES = {
    http_method: 'GET'.freeze,
    no_data: true,
  }

  def initialize(refresh_interval: 15, **kwargs)
    set_refresh_interval(refresh_interval)
    @client = V2CampaignManagerClient.new(**kwargs, **DEFAULT_OPTION_OVERRIDES)
  end

  def set_refresh_interval(i)
    @refresh_interval = i.to_i unless i.to_i == 0 # indicates a string, not a stringified number
    @refresh_interval ||= if i == 'increment'
      @increment_interval = true
      20
    else
      15
    end
  end

  def minutes_seconds_until_next_call(last_call_time)
    next_call = last_call_time + @refresh_interval * 60
    seconds_until_next = next_call - Time.now
    seconds_until_next.divmod(60).map(&:floor)
  end

  def run
    @start_time = Time.now
    resp = @client.run
    current_time = Time.now

    while true
      if Time.now - current_time > 60 * @refresh_interval
        current_time = Time.now
        resp = @client.run
        @refresh_interval += 5 if @increment_interval
      end

      system 'clear'
      $stdout.puts "Current refresh interval: #{@refresh_interval} minutes"
      $stdout.puts "Total uptime: #{(Time.now - @start_time).divmod(60).map { |n| n.floor.to_s.rjust(2, '0') }.join(':')}"
      $stdout.puts "Last refresh at #{current_time}"
      $stdout.puts "Last response: #{resp.code}"
      mins, secs = minutes_seconds_until_next_call(current_time).map(&:to_s)
      $stdout.puts "Next refresh in #{mins}:#{secs.rjust(2, '0')}"
      sleep 1
    end

  end
end

################
# Shell script #
################
if $PROGRAM_NAME == __FILE__
  options = {}
  OptionParser.new do |opts|
    opts.on(
      '-cCOOKIE',
      '--cookie=COOKIE',
      'The cookie from an authenticated Rally Central API call',
    ) do |cookie|
      options[:cookie] = cookie
    end

    opts.on(
      '-iINTERVAL',
      '--interval=INTERVAL',
      "The amount of time between API calls (in minutes); defaults to 15.\nUse 'increment' for an incremental test.",
    ) do |refresh_interval|
      options[:refresh_interval] = refresh_interval
    end

    opts.on('-l', '--last-used-args', 'Re-use the stored data from the last call') do
      options[:last_used] = true
    end

    opts.on('-tTENANT', '--tenant=TENANT', 'The dev tenant to send the CURL req to; defaults to `thankful-diet`') do |tenant|
      options[:tenant] = tenant
    end

    opts.on('-v', '--verbose', 'More loquacious') do
      options[:verbose] = true
    end

    opts.on_tail('-h', '--help', 'Show this help message') do
      puts opts
      exit
    end
  end.parse!

  unless options[:last_used]
    while options[:cookie].nil? || options[:cookie].empty?
      $stdout.print "\nEnter a valid cookie [REQUIRED] (paste from the headers of a recent RallyEngine call to the desired tenant):\n> "
      options[:cookie] = $stdin.gets.strip
    end
  end

  TokenRefrigerator.new(**options).run
end
